---
layout: post
title:  "ARM - Parte 1"
subtitle:
date:   2016-01-15 23:34:01
categories: [microcontroladores, potencia]
visible: true
---

Há algum tempo tenho vontade de saber programar em microcontroladores
ARM. Quando vi um com um bom custo-benefício a venda, resolvi
comprá-lo e fazer essa série de textos pra me ajudar a aprender o que
eu quero. Comprei um STM32F103C8T6, como o da imagem abaixo, que pode
ser encontrado por cerca de 3 dólares.

<p class="center">
<img src="../../../../../files/arm1/fig3.jpg" alt="Imagem"/>
</p>

Algumas das suas características são:  
- ARM Cortex-M3;  
- USB 2.0;  
- 7 timers;  
- SPI;  
- I2C;  
- CAN;  
- 3 USART's;  
- 2 conversores AD;  
- Frequência máxima de 72MHz;  

Nesta primeira parte irei falar sobre como ajustar a placa e o
ambiente, além de demonstrar um exemplo básico de uso.

Primeiramente, foi necessário soldar as barras de pinos na placa, 
quando a mesma chegou. Para isso, recomendo que os pinos sejam
fixados na protoboard.

<p class="center">
<img src="../../../../../files/arm1/fig2.jpg" alt="Imagem" />
</p>

Com essa etapa pronta, comecei a pesquisar como poderia ser feita a
programação do microcontrolador. Segundo a AN2606, os dispostivos
STM32 vêm com um bootloader instalado de fábrica, que permite
programar o microcontrolador através da USART, CAN, USB, SPI, etc.
As formas de programação disponíveis variam em cada dispositivo. 
Nesta
<a href="http://www.st.com/web/en/resource/technical/document/application_note/CD00167594.pdf#page=21&zoom=auto,-109,508">
tabela</a>
é possível identificar que, nesse microcontrolador, apenas a
programação por USART é disponibilizada.

<p class="center">
<img src="../../../../../files/arm1/table_embedded_bootloader.png" alt="Imagem"/>
</p>

Pacotes necessários:


https://sourceforge.net/projects/stm32flash/

{% highlight sh %}
sudo apt-get install gcc-arm-none-eabi \
binutils-arm-none-eabi gdb-arm-none-eabi \
build-essentials git libusb-1.0-0 libusb-dev \
stm32flash putty
{% endhighlight %}

Conversor USB/USART que comunica o computador com o microcontrolador:

<p class="center">
<img src="../../../../../files/arm1/usb-usart.jpg" alt="Imagem" />
</p>

Usei o modelo da foto acima, cujos drivers já estavam no linux. 
Conversores de 5V podem ser usados, já que o datasheet do STM32F103
especifica que os pinos RX e TX (e vários outros) suportam tal tensão.
Para testar o conversor, temos que descobrir em qual porta serial
ele está. Isso é feito através do comando 

{% highlight sh %}
dmesg | grep tty
{% endhighlight %}

Provavelmente a última linha trará a informação necessária:

{% highlight sh %}
[17535.429228] usb 1-1: pl2303 converter now attached to ttyUSB0
{% endhighlight %}

Logo, o conversor USB/USART está em /dev/ttyUSB0. Após isso, é só
fechar um curto-circuito nos pinos RX e TX do conversor e executar o
comando

{% highlight sh %}
putty /dev/ttyUSB0 -serial -sercfg 9600,8,n,1,N
{% endhighlight %}

Uma janela irá se abrir. Os caracteres digitados nessa janela devem
aparecer na mesma. Isso indica que o conversor está funcionando pois,
como RX e TX estão em curto, o que é recebido é o mesmo que foi
enviado.

Para testar o microcontrolador, o pino A9 da placa deve ser conectado
ao RX e o A10 ao TX. Além disso, o GND do conversor deve ser conectado
ao GND do  microcontrolador, e o mesmo deve ser alimentado com 3.3V.
É preciso configurar o BOOT0 e BOOT1, que são as chaves amarelas na
placa. O acesso ao bootloader é dado quando essas chaves são colocadas
no modo "System memory".

<p class="center">
<img src="../../../../../files/arm1/boot_modes.png" alt="Imagem" />
</p>

Coloque-as do mesmo modo que a imagem a seguir:

<p class="center">
<img src="../../../../../files/arm1/boot0_boot1_config.jpg" alt="Imagem" />
</p>

Além disso, a ST recomenda na AN2606 que resistores de 100kΩ sejam
usados como pull-up.

<p class="center">
<img src="../../../../../files/arm1/usart_connection.png" alt="Imagem" />
</p>

Após isso, é só resetar o microcontrolador no botão e executar o 
comando

{% highlight sh %}
stm32flash /dev/ttyUSB0
{% endhighlight %}

Se tudo funcionou corretamente, será retornado algo semelhante ao
seguinte código:

{% highlight sh %}
stm32flash 0.4

http://stm32flash.googlecode.com/

Interface serial_posix: 57600 8E1
Version      : 0x22
Option 1     : 0x00
Option 2     : 0x00
Device ID    : 0x0410 (Medium-density)
- RAM        : 20KiB  (512b reserved by bootloader)
- Flash      : 128KiB (sector size: 4x1024)
- Option RAM : 16b
- System RAM : 2KiB

{% endhighlight %}

Possíveis erros:

“Failed to init device”: dispositivo foi detectado mas houve algum
problema no reset. Resete e execute novamente o comando.

“Failed to open port: /dev/ttyUSB0": significa que uma porta incorreta
foi usada.

Com tudo isso funcionando, deve-se rodar o "blink" para testar o
funcionamento da programação do microcontrolador. O código completo
desse exemplo está no final do post. Junto ao projeto incluí
bibliotecas da própria ST para programar o STM32F103, mas optei por
não utilizá-las no exemplo, trabalhando diretamente com os
registradores. Segue o código principal do blink.


{% highlight C %}

#include "stm32f10x.h"

void delay ( unsigned long delay ) {
    while(delay) delay--;
}

int main ( void ) {
    // Enable GPIOC clock
    RCC->APB2ENR |= RCC_APB2Periph_GPIOC;
    // Configure pin as output push-pull (led)
    GPIOC->CRH = ( GPIO_CRH_MODE13 );
    while(1) {
        GPIOC->ODR ^= GPIO_Pin_13;
        delay( 1000000 );
    }
}

{% endhighlight %}


Inicialmente o clock dos periféricos não está habilitado, visando
economizar energia. Para que o PORTC funcione, devemos usar a
instrução "RCC->APB2ENR |= RCC_APB2Periph_GPIOC". A lista completa dos
registradores que podem ser habilitados está no arquivo
"stm32f10x_rcc.h".

<p class="center">
<img src="../../../../../files/arm1/APB2RSTR.png" alt="Imagem" />
</p>

Já o registrador CRH (GPIOC->CRH) é responsável pela configuração 
dos pinos de 8 a 15 em cada PORTx.

<p class="center">
<img src="../../../../../files/arm1/crh.png" alt="Imagem" />
</p>

Na instrução "GPIOC->CRH = ( GPIO_CRH_MODE13 )" é feita a configuração
do pino PC13 como uma saída. O valor "GPIO_CRH_MODE13" faz com que
ambos os bits correspondentes a esse pino sejam setados (MODEy[1:0]),
o que o configura com 50MHz, conforme mostra o Reference Manual. Nesse
caso é desnecessário configurar o CNFy: como seu valor de reset é 01,
ele já é uma saída. Para setar apenas um dos bits, poderia ser usada a
constante GPIO_CRH_MODE13_0 (bit 0) ou GPIO_CRH_MODE13_1 (bit 1). 

Dentro do loop infinito há uma periódica negação no registrador ODR,
utilizado para setar ou resetar o valor das saídas.

<p class="center">
<img src="../../../../../files/arm1/odr.png" alt="Imagem" /></p>

Para compilar e executar o código:

{% highlight sh %}
make
make flash
stm32flash -w blink-cmsis_firmware.bin -v -g 0x0 /dev/ttyUSB0
{% endhighlight %}

Esse último comando grava o arquivo gerado no make na memória do
microcontrolador, verifica a gravação e logo depois inicia a execução
no endereço especificado (0x0). Se tudo ocorreu bem, após a execução
dele o led embutido na placa começará a piscar.

As bibliotecas e o Makefile do exemplo foram modificados a partir de
https://github.com/istepaniuk/stm32-templates

Links úteis:

<a href="https://github.com/marcohab/stm32f103c8t6_blink">Código do blink</a>

<a href="http://www.st.com/web/en/resource/technical/document/
reference_manual/DM00031020.pdf">Reference Manual</a>

<a href="http://www.st.com/web/en/resource/technical/document/
programming_manual/CD00228163.pdf">Programming Manual</a>

<a href="http://www.st.com/web/en/resource/technical/document/
application_note/CD00167594.pdf">AN2606</a>
